package transactions;
import connection.*;
import entity.*;

import java.sql.*;
import java.time.LocalDate;
import java.util.List;
import java.util.ArrayList;

public class BorrowTransactions {

    private final DatabaseConnection dbConnection;

    public BorrowTransactions() {
        this.dbConnection = new DatabaseConnection();
    }

    /**
     * Retrieves all borrow requests from the database.
     */
    public List<BorrowRequest> getAllBorrowRequests() {
        List<BorrowRequest> requests = new ArrayList<>();
        Connection conn = dbConnection.getConnection();
        String sql = "SELECT borrow_code, player_id, deck_id, borrow_type, request_date, status, return_date FROM borrow_request";
        try (PreparedStatement pstmt = conn.prepareStatement(sql);
             ResultSet rs = pstmt.executeQuery()) {
            while (rs.next()) {
                int borrowCode = rs.getInt("borrow_code");
                int playerId = rs.getInt("player_id");
                int deckId = rs.getInt("deck_id");
                String borrowType = rs.getString("borrow_type");
                java.sql.Date reqDate = rs.getDate("request_date");
                String status = rs.getString("status");
                java.sql.Date retDate = rs.getDate("return_date");
                requests.add(new entity.BorrowRequest(
                    borrowCode,
                    playerId,
                    deckId,
                    borrowType,
                    reqDate != null ? reqDate.toLocalDate() : null,
                    status,
                    retDate != null ? retDate.toLocalDate() : null
                ));
            }
        } catch (SQLException e) {
            System.err.println("Error fetching borrow requests: " + e.getMessage());
        }
        return requests;
    }

    /**
     * Checks if a deck is currently available.
     * Logic: A deck is unavailable if it is in 'Approved' or 'Pending' status
     * and has not been returned yet.
     */
    public boolean isDeckAvailable(int deckId) {
        Connection conn = dbConnection.getConnection();
        String sql = "SELECT COUNT(*) FROM borrow_request WHERE deck_id = ? AND status IN ('Pending', 'Approved')";

        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, deckId);
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    return rs.getInt(1) == 0;
                }
            }
        } catch (SQLException e) {
            System.err.println("Availability check failed: " + e.getMessage());
        }
        return false;
    }

    /**
     * Processes a Borrow Request.
     * Automatically sets borrow_type:
     * - "Available Borrow" if deck is available
     * - "Pending Borrow" if deck is not available (waits for previous borrower)
     * borrow_code is auto-generated by DB.
     */
    public boolean requestBorrow(int playerId, int deckId) {
        Connection conn = dbConnection.getConnection();
        boolean available = isDeckAvailable(deckId);
        String borrowType = available ? "Available Borrow" : "Pending Borrow";
        String sql = "INSERT INTO borrow_request (player_id, deck_id, borrow_type, request_date, status) VALUES (?, ?, ?, ?, 'Pending')";

        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setInt(1, playerId);
            pstmt.setInt(2, deckId);
            pstmt.setString(3, borrowType);
            pstmt.setDate(4, Date.valueOf(LocalDate.now()));

            int affectedRows = pstmt.executeUpdate();
            return affectedRows > 0;
        } catch (SQLException e) {
            System.err.println("Error processing borrow request: " + e.getMessage());
            return false;
        }
    }

    /**
     * Updates a borrow request to "Returned".
     */
    public boolean returnDeck(int borrowCode) {
        Connection conn = dbConnection.getConnection();
        String sql = "UPDATE borrow_request SET status = 'Returned', return_date = ? WHERE borrow_code = ?";

        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setDate(1, Date.valueOf(LocalDate.now()));
            pstmt.setInt(2, borrowCode);
            return pstmt.executeUpdate() > 0;
        } catch (SQLException e) {
            System.err.println("Error returning deck: " + e.getMessage());
            return false;
        }
    }
}